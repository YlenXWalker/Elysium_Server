/**************************************************************************\
*                                                                          *
*   Copyright (C) 2018-2024 Andrei Karas (4144)                            *
*   Copyright (C) 2021-2024 X-EcutiOnner (xex.ecutionner@gmail.com)        *
*                                                                          *
*   This file is a part of WARP project                                    *
*                                                                          *
*   WARP is free software: you can redistribute it and/or modify           *
*   it under the terms of the GNU General Public License as published by   *
*   the Free Software Foundation, either version 3 of the License, or      *
*   (at your option) any later version.                                    *
*                                                                          *
*   This program is distributed in the hope that it will be useful,        *
*   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
*   GNU General Public License for more details.                           *
*                                                                          *
*   You should have received a copy of the GNU General Public License      *
*   along with this program.  If not, see <http://www.gnu.org/licenses/>.  *
*                                                                          *
*                                                                          *
|**************************************************************************|
*                                                                          *
*   Author(s)     : Andrei (4144)                                          *
*   Created Date  : 2021-06-15                                             *
*   Last Modified : 2024-08-09                                             *
*                                                                          *
\**************************************************************************/

// TODO - Clients post 2017-10-00, seems to be doing this properly with a loop.
//        Check later if a fix is really needed.

FixAchieveCounters = function(_)
{
	$$(_, 1.1, `Find the location where the image name is PUSHed`)
	const startAddr = Exe.FindHex(PUSH(this.BmpAddr) + CALL());
	if (startAddr < 0)
		throw Error("BG not pushed");

	$$(_, 1.2, `Find the format string`)
	let addr = Exe.FindText("%d/%d");
	if (addr < 0)
		throw Error("Format string missing");

	$$(_, 1.3, `Find where it is used for the global counter`)
	let parts =
	[
		MOV(EDX, [EDI, WCp]) //mov edx, dword ptr [edi + dispA]
	+	MOV(EAX, [EDX, 4])   //mov eax, dword ptr [edx+4]  <-- type1
	,
		MOV(ECX, [EAX, WCp]) //mov ecx, dword ptr [eax + dispB]
	+	MOV(EAX, [EDX])      //mov eax, dword ptr [edx]
	,
		PUSH(ECX)            //push ecx
	+	PUSH([EAX, WCp])     //push dword ptr [eax + dispC]
	+	LEA(EAX, [EBP, WC])  //lea eax, [ebp + <dstStr>]
	+	PUSH(addr)           //push offset "%d/%d"
	+	PUSH_EAX             //push eax
	+	CALL()               //call std::string::printf
	];

	addr = Exe.FindHex(parts, startAddr, startAddr + 0x500);

	$$(_, 1.4, `Point addr1 to position of the type1 offset`)
	let addr1;
	if (addr > 0)
		addr1 = addr + parts.byteCount(0) - 1;
	else if (Exe.BuildDate < 20170000)
		throw Error("Pattern not found");

	$$(_, 1.5, `Repeat for the other category counters (there should be 5 of them)`)
	parts[1] =
		MOV(ECX, [EAX, WCp]) //mov ecx, dword ptr [eax + dispB]
	+	MOV(EAX, [EDX, WCp]) //mov eax, dword ptr [edx + offset#1] <-- type2
	;

	const addrs = Exe.FindHexN(5, 5, parts, addr1 ?? startAddr, startAddr + 0x500);
	if (addrs.isEmpty())
		throw Error("Expected exactly 5 matches for 2nd pattern");

	$$(_, 1.6, `Verify that global counter was found properly`)
	if (addr1 && (addr1 + 0x200) < addrs[0])
		throw Error("Found false match");

	$$(_, 2.1, `Setup the offsets for the type1 and type2 displacements`)
	const type1Off = parts.byteCount(0) - 1;
	const type2Off = type1Off + parts.byteCount(1);

	$$(_, 2.2, `Prepare the pattern to check for false positives`)
	const code =
		PUSH(POS2WC)                 //push <msgId>
	+	MOV([EBP, WC], 0xF)          //mov dword ptr [ebp + dstStr.m_allocated_len], 0Fh
	+	MOV([EBP, WC], 0)            //mov dword ptr [ebp + dstStr.m_len], 0
	+	MOV(BYTE_PTR, [EBP, WC], 0)  //mov byte ptr [ebp + dstStr.m_cstr], 0
	+	CALL(ALLWC)                  //call MsgStr
	+	ADD(ESP, 4)                  //add esp, 4
	+	MOV(ECX, EDI)                //mov ecx, edi
	+	PUSH_EAX                     //push eax
	;

	$$(_, 2.3, `Setup the variables for the various categories`)
	let msgAddrs = [];
	let msgIDs = [];
	let type1Addrs = [];
	let type2Addrs = [];

	$$(_, 2.4, `Extract the values for all 5 categories`)
	addrs.forEach( (memAddr, i) =>
	{
		const addr = Exe.FindHex(code, memAddr - 0x40, memAddr);
		if (addr < 0)
			throw Error(`Failed for match no.${i}`);

		msgAddrs.push(addr);
		msgIDs.push(Exe.GetInt32(addr + 1));
		type1Addrs.push(memAddr + type1Off);
		type2Addrs.push(memAddr + type2Off);
	});

	$$(_, 2.5, `If addr1 was defined then change it to 0`)
	if (addr1)
		Exe.SetInt8(addr1, 0);

	$$(_, 2.6, `Swap the category values`)
	for (const [from, to] of
	[
		[0, 1], //Adventure -> Battle    (52, 9d)
		[1, 3], //Battle    -> Memorial  (52, cf)
		[2, 0], //Quest     -> Adventure (180, 6b)
		[3, 2], //Memorial  -> Quest     (180, 9d)
	])
	{
		Exe.SetInt32(msgAddrs[from] + 1, msgIDs[to]);
		Exe.SetInt8(addrs[from] + type1Off, type1Addrs[to]);
		Exe.SetInt8(addrs[from] + type2Off, type2Addrs[to]);
	}

	$$(_, 2.7, `Set the type1 offset for Feat (180, cf)`)
	Exe.SetInt8(addrs[4] + type1Off, type2Addrs[4]);

	return true;
};

///
/// \brief Disable for unsupported clients
///
FixAchieveCounters.validate = function()
{
	if (Exe.BuildDate > 20171000) //disabling for now
		return false;

	this.BmpAddr = Exe.FindText("\xC0\xAF\xC0\xFA\xC0\xCE\xC5\xCD\xC6\xE4\xC0\xCC\xBD\xBA\\achievement_re\\bg_summary.bmp");
	return (this.BmpAddr > 0);
};
