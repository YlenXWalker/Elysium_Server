/**************************************************************************\
*                                                                          *
*   Copyright (C) 2021-2023 Neo-Mind                                       *
*                                                                          *
*   This file is a part of WARP project (specific to RO clients)           *
*                                                                          *
*   WARP is free software: you can redistribute it and/or modify           *
*   it under the terms of the GNU General Public License as published by   *
*   the Free Software Foundation, either version 3 of the License, or      *
*   (at your option) any later version.                                    *
*                                                                          *
*   This program is distributed in the hope that it will be useful,        *
*   but WITHOUT ANY WARRANTY; without even the implied warranty of         *
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the          *
*   GNU General Public License for more details.                           *
*                                                                          *
*   You should have received a copy of the GNU General Public License      *
*   along with this program.  If not, see <http://www.gnu.org/licenses/>.  *
*                                                                          *
*                                                                          *
|**************************************************************************|
*                                                                          *
*   Author(s)     : Neo-Mind                                               *
*   Created Date  : 2021-01-22                                             *
*   Last Modified : 2023-08-26                                             *
*                                                                          *
\**************************************************************************/

///
/// \brief Generate Curiosity's Map Effect Plugin for loaded client
///        using the template DLL (rdll2.asi) along with header file.
///
GenMapEffectPlugin = function(_)
{
	$$(_, 1.1, `Open the template file & ensure exe file is valid`)
	if (Exe.FileSize == 0)
		throw NO_EXE;

	let handle = new BinFile("Inputs/rdll2.asi");
	if (!handle.Valid)
		throw Error("Template file is inaccessible");

	$$(_, 1.2, `Find the string 'xmas_fild01.rsw'`)
	let addr = Exe.FindText("xmas_fild01.rsw", CASE_INSENSITIVE);
	if (addr < 0)
		throw Error("'xmas_fild01.rsw' not found");

	$$(_, 1.3, `Find all locations where it is MOVed into a register`)
	let prefix = MOV(R32, addr); //mov regA, offset "xmas_fild01.rsw"
	let suffix = MOV(R8, [R32]); //mov reg8B, dword ptr [regC]

	let addrs;
	if (Exe.BuildDate > 20100910 && Exe.BuildDate < 20101200)
		addrs = [
			...Exe.FindHexN(prefix + LEA(R32, [R32, 0]) + suffix),
			...Exe.FindHexN(prefix + LEA(ESP, [ESP, 0]) + suffix)
		];
	else
		addrs = Exe.FindHexN(prefix + suffix);

	if (addrs.isEmpty())
		throw Error("'xmas_fild01.rsw' not used");

	$$(_, 1.4, `Find the string 'gef_fild07.rsw'`)
	addr = Exe.FindText("gef_fild07.rsw", CASE_INSENSITIVE);
	if (addr < 0)
		throw Error("'gef_fild07.rsw' not found");

	$$(_, 1.5, `Find the appropriate one using its address, which will be at the CGameMode_Initialize_EntryPtr`)
	const CI_Entry = addrs.find(memAddr => Exe.FindHex(MOV(R32, addr), memAddr + 0x40, memAddr + 0x120) > 0); //mov regD, offset "gef_fild07.rsw"
	if (CI_Entry < 0)
		throw Error("Correct match not found");

	$$(_, 2.1, `Look for g_Weather assignment before EntryPtr`)
	code =
		MOV(ECX, POS4WC) //mov ecx, <g_Weather>
	+	CALL()           //call CWeather::ScriptProcess
	;
	addr = Exe.FindLastHex(code, CI_Entry, CI_Entry - 0x10);
	if (addr < 0)
		throw Error("g_Weather assignment missing");

	$$(_, 2.2, `Extract g_Weather and the MOV ECX instruction`)
	const Weather = Exe.GetInt32(addr + 1);
	const movWeather = Exe.GetHex(addr, 5);

	$$(_, 2.3, `Find the CALL to LaunchPokJuk to determine the CGameMode_Initialize_ExitPtr`)
	code =
		JE(' 0?')   //je short _skip#1
	+	movWeather  //mov ecx, <g_Weather>
	+	CALL()      //call CWeather::LaunchPokJuk
	;
	addr = Exe.FindHex(code, CI_Entry + 10);
	if (addr < 0)
		throw Error("return point missing");

	$$(_, 2.4, `Save the address after the CALL and the CALLed address`)
	addr += code.byteCount();

	const CW_LPokJuk = Exe.GetTgtAddr(addr);
	const CI_Exit = addr + 4;

	$$(_, 3.1, `Find the string 'yuno.rsw'`)
	const yunoAddr = Exe.FindText("yuno.rsw", CASE_INSENSITIVE);
	if (yunoAddr < 0)
		throw Error("'yuno.rsw' not found");

	$$(_, 3.2, `Find its reference between CGameMode_Initialize_EntryPtr & CGameMode_Initialize_ExitPtr`)
	prefix = MOV(R32, yunoAddr);
	suffix = MOV(R8, [R32]);

	addr = Exe.FindHex(prefix + suffix, CI_Entry + 0x10, CI_Exit);
	if (addr < 0)
	{
		prefix += NOP7;
		addr = Exe.FindHex(prefix + suffix, CI_Entry + 0x10, CI_Exit);
	}
	if (addr < 0 && Exe.BuildDate > 20190000)
	{
		prefix = prefix.replace(NOP7, LEA(ESP, [ESP, ALL00]));
		addr = Exe.FindHex(prefix + suffix, CI_Entry + 0x10, CI_Exit);
	}
	if (addr < 0)
		throw Error("'yuno.rsw' not used");

	$$(_, 3.3, `Find the JZ below it which leads to calling LaunchCloud`)
	addr += prefix.byteCount() + suffix.byteCount();

	addr = Exe.FindHex(JZ(POS2WC), addr, addr + 0x80);
	if (addr < 0)
		throw Error("LaunchCloud Jump missing");

	$$(_, 3.4, `Extract the instruction at the JZ target & save its Displacement value (g_useEffect)`)
	let ins = Instr.FromAddr(Exe.GetTgtAddr(addr + 2, PHYSICAL));

	const UseEffect = ins.Disp;
	if (!UseEffect)
		throw Error("g_useEffect not found");

	$$(_, 3.5, `Find the call to LaunchCloud after it`)
	addr = ins.NextAddr;

	code =
		movWeather //mov ecx, <g_Weather>
	+	CALL()     //call CWeather::LaunchCloud
	;
	addr = Exe.FindHex(code, addr, addr + 0x80);
	if (addr < 0)
		throw Error("LaunchCloud CALL missing");

	$$(_, 3.6, `Save the function address`)
	const CW_LCloud = Exe.GetTgtAddr(addr + code.byteCount());

	$$(_, 3.7, `Find the 2nd reference to 'yuno.rsw' which serves as CGameMode_OnInit_EntryPtr`)
	code = MOV(EAX, yunoAddr);
	let CO_Entry = Exe.FindLastHex(code, CI_Entry);

	if (CO_Entry < 0)
		CO_Entry = Exe.FindHex(code, CI_Exit);

	if (CO_Entry < 0)
		throw Error("2nd yuno reference missing");

	$$(_, 4.1, `Find the JZ after CGameMode_OnInit_EntryPtr`)
	addr = Exe.FindHex(JZ(POS2WC), CO_Entry + 5, CO_Entry + 0x80);
	if (addr < 0)
		throw Error("g_renderer Jump missing");

	$$(_, 4.2, `Extract the instruction at the JZ target & save its Displacement value (g_renderer)`)
	ins = Instr.FromAddr(Exe.GetTgtAddr(addr + 2, PHYSICAL));

	const Renderer = ins.Disp;
	if (!Renderer)
		throw Error("g_renderer not referenced");

	$$(_, 4.3, `Goto the next instruction & save its Displacement (clearColor offset)`)
	ins = Instr.FromAddr(ins.NextAddr);

	const clearColor = ins.Disp;
	if (!clearColor)
		throw Error("clearColor assignment missing");

	if (clearColor > 0x7F)
		throw Error("Clear Color is more than 1 byte");

	$$(_, 4.4, `Goto the last clearColor assignment`)
	addr = ins.NextAddr;

	const clr = Exe.BuildDate > 20130000 ? 0xFF1A0A08 : 0xFF330033;

	let delta, reg;
	if ((Exe.Version === 9.0 || Exe.Version === 10.0) &&
	    (Exe.BuildDate < 20120820 || Exe.BuildDate > 20130000))
	{
		delta = 0xD; //for the short jump to _skip#1
		reg = R32;
	}
	else
	{
		delta = 0xC; //for the short jump to _skip#1
		reg = EAX;
	}

	code =
		JNE(delta)                   //jne short _skip#1
	+	MOV(reg, [Renderer])         //mov regA, dword ptr [g_renderer] ; regA is eax for certain versions/dates
	+	MOV([reg, clearColor], clr)  //MOV dword ptr [regA + <clearColor>], <color>
	;

	addr = Exe.FindHex(code, addr, addr + 0x300);
	if (addr < 0)
		throw Error("CO Exit point missing");

	$$(_, 4.5, `Save the address after the assignment as CGameMode_OnInit_ExitPtr`)
	let CO_Exit = addr + code.byteCount();

	$$(_, 5.1, `Find the CALL to CWeather::LaunchSnow after CGameMode_Initialize_EntryPtr`)
	code =
		JZ(7)       //jz short _snowstop -> Calls StopSnow
	+	CALL(ALLWC) //call CWeather::LaunchSnow
	+	JMP(5)      //jmp short _snowskip -> Skip StopSnow
	+	CALL()      //call CWeather::StopSnow ; _snowstop
	                //<remaining code>        ; _snowskip
	;
	addr = Exe.FindHex(code, CI_Entry + 0x20, CI_Entry + 0x100);
	if (addr < 0)
		throw Error("Snow CALLs missing");

	$$(_, 5.2, `Save the LaunchSnow function address`)
	const CW_LSnow = Exe.GetTgtAddr(addr + 3);

	$$(_, 5.3, `Find the LaunchNight function`)
	let interval = Exe.Version < 9.0 ? NOP : INT3;
	code =
		interval                  //nop or int3
	+	MOV(BYTE_PTR, [ECX], 1)   //mov byte ptr [ecx], 1
	+	RETN()                    //retn
	+	interval.repeat(3)        //nop or int3 x3
	;
	let addrNight = Exe.FindHex(code);
	if (addrNight < 0)
		throw Error("LaunchNight function missing");

	$$(_, 5.4, `Save the LaunchNight function address`)
	let CW_LNight = Exe.Phy2Vir(addrNight + 1, CODE);

	$$(_, 6.1, `Find the pattern inside LaunchMaple function`)

	prefix = PUSH(0x14D);           //push 14Dh

	suffix = Exe.Version > 11.0 ?
		     MOV(R32, [R32, WCp])   //mov regA, dword ptr [regB + dispB]
	       : Exe.Version > 6.0 ?    //   OR
		     MOV([R32, ' 1?'], R32) //mov dword ptr [regA + dispA], regB
		   :                        //   OR
		     MOV([R32], R32)        //mov dword ptr [regA], regB
		   ;

	const addrM = Exe.FindLastHex(prefix + suffix, addrNight);
	if (addrM < 0)
		throw Error("LaunchMaple marker missing");

	$$(_, 6.2, `Find the function's starting address`)
	code =
		(ROC.HasFP
	?
		FP_START         //push ebp
		                 //mov ebp, esp
	:
		''
	)
	+	SUB(ESP, WCp)   //sub esp, immA
	+	PUSH(ESI)       //push esi
	+	(Exe.BuildDate > 20180910
	?
		PUSH_R          //push regA
	:
		''
	)
	+	MOV(R32, ECX)   //mov regB, ecx
	;
	addr = Exe.FindLastHex(code, addrM, addrM - 0x80);
	if (addr < 0)
		throw Error("LaunchMaple start missing");

	$$(_, 6.3, `Save the function address`)
	const CW_LMaple = Exe.Phy2Vir(addr, CODE);

	$$(_, 6.4, `Find the pattern inside LaunchSakura`)
	prefix = PUSH(0xA3);

	if (Exe.Version < 11.0)
		addr = Exe.FindLastHex(prefix + suffix, addr);
	else
		addr = Exe.FindHex(prefix + suffix, addrNight, addrNight + 0x300);

	if (addr < 0)
		throw Error("LaunchSakura marker missing");

	$$(_, 6.5, `Find the function's starting address`)
	addr = Exe.FindLastHex(code, addr, addr - 0x80);
	if (addr < 0)
		throw Error("LaunchSakura start missing");

	$$(_, 6.6, `Save the function address`)
	const CW_LSakura = Exe.Phy2Vir(addr, CODE);

	$$(_, 7.1, `Extract the DLL contents`)

	let dll = handle.ReadHex();
	handle.Close();

	$$(_, 7.2, `Fill in the values`)
	dll = dll.replace(/ C1 C1 C1 C1/i, Weather.toHex());
	dll = dll.replace(/ C2 C2 C2 C2/i, Renderer.toHex());
	dll = dll.replace(/ C3 C3 C3 C3/i, UseEffect.toHex());

	code =
		CW_LCloud.toHex()
	+	CW_LSnow.toHex()
	+	CW_LMaple.toHex()
	+	CW_LSakura.toHex()
	+	CW_LPokJuk.toHex()
	+	CW_LNight.toHex()
	;
	dll = dll.replace(/ C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4 C4/i, code);

	dll = dll.replace(/ C5 C5 C5 C5/i, Exe.Phy2Vir(CI_Entry, CODE).toHex());
	dll = dll.replace(/ C7 C7 C7 C7/i, Exe.Phy2Vir(CI_Exit,  CODE).toHex());
	dll = dll.replace(/ C6 C6 C6 C6/i, Exe.Phy2Vir(CO_Entry, CODE).toHex());
	dll = dll.replace(/ C8 C8 C8 C8/i, Exe.Phy2Vir(CO_Exit,  CODE).toHex());

	dll = dll.replace(/ 6C 5D C3/i, clearColor.toHex(1) + " 5D C3");

	$$(_, 7.3, `Write out the updated contents`)

	const dir = Exe.GetUserInput("$$rdllOutput", D_Folder, "Target Folder", "Enter the target folder to place the plugin at", OUTDIR);
	if (dir === false)
		return true;

	if (!handle.Open(dir + "/rdll2_" + ROC.BaseName + ".asi", 'w'))
		throw Error("Unable to write the output file");

	handle.WriteHex(dll);
	handle.Close();

	$$(_, 7.4, `Generate the header (just for reference)`)
	handle = new TextFile(OUTDIR + "client_" + ROC.BaseName + ".h", 'w');
	if (handle.Valid)
	{
		handle.WriteLine("#include <WTypes.h>");
		handle.WriteLine("\n// Client Date : " + Exe.BuildDate);
		handle.WriteLine("\n// Client offsets - some are #define because they were appearing in multiple locations unnecessarily");
		handle.WriteLine("#define G_WEATHER 0x" + Weather.toHex(true) + ";");
		handle.WriteLine("#define G_RENDERER 0x" + Renderer.toHex(true) + ";");
		handle.WriteLine("#define G_USEEFFECT 0x" + UseEffect.toHex(true) + ";");
		handle.WriteLine("\nDWORD CWeather_EffectId2LaunchFuncAddr[] = {\n\tNULL, //CEFFECT_NONE");
		handle.WriteLine("\t0x" + CW_LCloud.toHex(true)  + ", // CEFFECT_SKY -> void CWeather::LaunchCloud(CWeather this<ecx>, char param)");
		handle.WriteLine("\t0x" + CW_LSnow.toHex(true)   + ", // CEFFECT_SNOW -> void CWeather::LaunchSnow(CWeather this<ecx>)");
		handle.WriteLine("\t0x" + CW_LMaple.toHex(true)  + ", // CEFFECT_MAPLE -> void CWeather::LaunchMaple(CWeather this<ecx>)");
		handle.WriteLine("\t0x" + CW_LSakura.toHex(true) + ", // CEFFECT_SAKURA -> void CWeather::LaunchSakura(CWeather this<ecx>)");
		handle.WriteLine("\t0x" + CW_LPokJuk.toHex(true) + ", // CEFFECT_POKJUK -> void CWeather::LaunchPokJuk(CWeather this<ecx>)");
		handle.WriteLine("\t0x" + CW_LNight.toHex(true)  + ", // CEFFECT_NIGHT -> void CWeather::LaunchNight(CWeather this<ecx>)");
		handle.WriteLine("};\n");

		handle.WriteLine("void* CGameMode_Initialize_EntryPtr = (void*)0x" + Exe.Phy2Vir(CI_Entry, CODE).toHex(true) + ";");
		handle.WriteLine("void* CGameMode_Initialize_ExitPtr = (void*)0x" + Exe.Phy2Vir(CI_Exit, CODE).toHex(true) + ";");
		handle.WriteLine("void* CGameMode_OnInit_EntryPtr = (void*)0x" + Exe.Phy2Vir(CO_Entry, CODE).toHex(true) + ";");
		handle.WriteLine("void* CGameMode_OnInit_ExitPtr  = (void*)0x" + Exe.Phy2Vir(CO_Exit, CODE).toHex(true) + ";");

		handle.WriteLine("\r\n#define GR_CLEAR " + (clearColor/4) + ";");
		handle.Close();
	}

	$$(_, 7.5, `Copy the related text file to 'data' folder inside if user wants to.`)
	if (!Warp.TestMode)
	{
		let response = UserChoice("Copy File", "Would you like the <b>'mapeffecttable.txt'</b> file copied to <b>'data'</b> sub folder inside?");
		if (response)
		{
			const tgtDir = dir + "/data";
			if (System.MkDir(tgtDir))
				System.Copy("Inputs/mapeffecttable.txt", tgtDir);
		}

		response = UserChoice("Show Folder", "Display the folder with the generated file?");
		if (response)
		{
			Warp.ShowInDir(dir + "/rdll2_" + ROC.BaseName + ".asi");
			return true;
		}
	}

	$$(_, 7.6, `Display the success message if file is not shown (or in TestMode)`)
	return "Plugin ASI generated in specified folder";
};
